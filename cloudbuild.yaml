# cloudbuild.yaml (v12 - Workspace build, GCS cache, based on SO example)

# Use a faster machine type as suggested
options:
  substitution_option: 'ALLOW_LOOSE'
  logging: CLOUD_LOGGING_ONLY

substitutions:
  # User's substitutions
  _SERVICE_NAME: web-app
  _DEPLOY_REGION: europe-west2
  _AR_HOSTNAME: europe-west2-docker.pkg.dev
  _AR_PROJECT_ID: apprenticewatch-55cb9
  _AR_REPOSITORY: cloud-run-source-deploy
  _PLATFORM: managed
  _IMAGE_NAME: ${_AR_HOSTNAME}/${_AR_PROJECT_ID}/${_AR_REPOSITORY}/${REPO_NAME}/${_SERVICE_NAME} # User's image name format
  _CACHE_BUCKET: gs://apprentice-watch-web-build-cache-g
  _CACHE_ARCHIVE_NPM: cache-npm.tar.gz
  _CACHE_ARCHIVE_NEXT: cache-next.tar.gz
  _NODE_VERSION: '18'
  # ENV VARS (Define securely in Trigger UI)
  _NEXT_PUBLIC_SUPABASE_URL: https://swtrxonxzchgudehqdge.supabase.co
  _NEXT_PUBLIC_SUPABASE_ANON_KEY: 'your-anon-key'
  _NEXT_PUBLIC_BASE_URL: https://apprenticewatch.com
  _NEXT_PUBLIC_LOGODEV_KEY: 'your-logodev-key'
  _NEXT_PUBLIC_GEMINI_API_KEY: 'your-gemini-key'
  _NEXT_PUBLIC_MAPBOX_TOKEN: 'your-mapbox-token'
  _NEXT_PUBLIC_GA_TRACKING_ID: G-1GKBR9HKF3
  _REVALIDATION_SECRET_TOKEN: 'your-secret-token'
  # From SO example (adapt if needed)
  _LATEST_TAG_NAME: 'latest' # Use 'latest' for docker --cache-from

steps:
  # 0. Get package lock hash
  - name: 'bash'
    id: 'Get package lock hash'
    script: |
      #!/usr/bin/env bash
      set -e
      LOCKFILE_HASH="no-lock-file"; if [[ -f "package-lock.json" ]]; then LOCKFILE_HASH=$(sha1sum package-lock.json | awk '{ print $1 }'); echo "Using package-lock.json hash: ${LOCKFILE_HASH}"; elif [[ -f "yarn.lock" ]]; then LOCKFILE_HASH=$(sha1sum yarn.lock | awk '{ print $1 }'); echo "Using yarn.lock hash: ${LOCKFILE_HASH}"; else echo "Warning: No lock file found."; fi; echo "${LOCKFILE_HASH}" > /workspace/pkg_lock_sha.txt

  # 1. Restore NPM Cache from GCS
  - id: restore-npm-cache
    name: 'gcr.io/cloud-builders/gsutil'
    waitFor: ['Get package lock hash'] # Wait for hash file
    script: |
      #!/usr/bin/env bash
      set -Eeuo pipefail
      LOCK_HASH=$(cat /workspace/pkg_lock_sha.txt)
      if [[ "${LOCK_HASH}" == "no-lock-file" ]]; then echo "Skipping NPM cache download (no lock file)."; exit 0; fi
      CACHE_PATH="gs://${_CACHE_BUCKET}/npm-${LOCK_HASH}-${_CACHE_ARCHIVE_NPM}"
      ARCHIVE_FILE="/workspace/${_CACHE_ARCHIVE_NPM}"
      echo "Attempting to download NPM cache: ${CACHE_PATH}"
      (gsutil -q cp "${CACHE_PATH}" "${ARCHIVE_FILE}") \
      && (echo "NPM cache archive downloaded. Extracting..." && mkdir -p /workspace/.npm && tar -xzmf "${ARCHIVE_FILE}" -C /workspace/.npm && rm "${ARCHIVE_FILE}" && echo "NPM cache extracted.") \
      || echo "NPM cache not found or download/extract failed."

  # 2. Restore .next Cache from GCS
  - id: restore-next-cache
    name: 'gcr.io/cloud-builders/gsutil'
    waitFor: ['-'] # Can run in parallel with NPM cache download
    script: |
      #!/usr/bin/env bash
      set -Eeuo pipefail
      CACHE_PATH="gs://${_CACHE_BUCKET}/latest-${_CACHE_ARCHIVE_NEXT}"
      ARCHIVE_FILE="/workspace/${_CACHE_ARCHIVE_NEXT}"
      echo "Attempting to download .next cache: ${CACHE_PATH}"
      (gsutil -q cp "${CACHE_PATH}" "${ARCHIVE_FILE}") \
      && (echo ".next cache archive downloaded. Extracting..." && mkdir -p /workspace/.next/cache && tar -xzmf "${ARCHIVE_FILE}" --strip-components=1 -C /workspace/.next/cache && rm "${ARCHIVE_FILE}" && echo ".next cache extracted.") \
      || echo ".next cache not found or download/extract failed."

  # 3. Install Dependencies (uses restored /workspace/.npm if available)
  - id: npm-ci
    name: 'node:${_NODE_VERSION}'
    waitFor: ['restore-npm-cache'] # Wait for attempt to restore .npm cache
    entrypoint: npm
    # Use the path where cache was extracted
    args: ['ci', '--cache', '/workspace/.npm', '--prefer-offline']

  # 4. Build Next.js App (uses restored /workspace/.next/cache if available)
  - id: npm-build
    name: 'node:${_NODE_VERSION}'
    waitFor: ['npm-ci', 'restore-next-cache'] # Wait for install and attempt to restore .next cache
    entrypoint: npm
    args: ['run', 'build']
    env: # Pass build-time env vars
      - 'NODE_ENV=production'
      - 'NEXT_PUBLIC_SUPABASE_URL=${_NEXT_PUBLIC_SUPABASE_URL}'
      - 'NEXT_PUBLIC_SUPABASE_ANON_KEY=${_NEXT_PUBLIC_SUPABASE_ANON_KEY}'
      - 'NEXT_PUBLIC_BASE_URL=${_NEXT_PUBLIC_BASE_URL}'
      - 'NEXT_PUBLIC_LOGODEV_KEY=${_NEXT_PUBLIC_LOGODEV_KEY}'
      - 'NEXT_PUBLIC_GEMINI_API_KEY=${_NEXT_PUBLIC_GEMINI_API_KEY}'
      - 'NEXT_PUBLIC_MAPBOX_TOKEN=${_NEXT_PUBLIC_MAPBOX_TOKEN}'
      - 'NEXT_PUBLIC_GA_TRACKING_ID=${_NEXT_PUBLIC_GA_TRACKING_ID}'

  # 5. Save NPM Cache to GCS
  - id: save-npm-cache
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk:slim' # Has tar and gsutil
    waitFor: ['npm-ci'] # Save after dependencies are installed/verified
    script: |
      #!/usr/bin/env bash
      set -Eeuo pipefail
      LOCK_HASH=$(cat /workspace/pkg_lock_sha.txt)
      if [[ "${LOCK_HASH}" == "no-lock-file" ]]; then echo "Skipping NPM cache save (no lock file)."; exit 0; fi
      CACHE_PATH="gs://${_CACHE_BUCKET}/npm-${LOCK_HASH}-${_CACHE_ARCHIVE_NPM}"
      ARCHIVE_FILE="/workspace/${_CACHE_ARCHIVE_NPM}" # Use workspace for temp file
      SOURCE_DIR=".npm" # Relative path in /workspace
      if [[ -d "/workspace/${SOURCE_DIR}" ]] && [[ -n "$(ls -A /workspace/${SOURCE_DIR})" ]]; then
        echo "Creating and uploading NPM cache to ${CACHE_PATH}..."
        (cd /workspace && tar --ignore-failed-read -czf "${ARCHIVE_FILE}" "${SOURCE_DIR}") && \
        gsutil -q -h "Cache-Control:private, max-age=0, no-transform" cp "${ARCHIVE_FILE}" "${CACHE_PATH}" && \
        rm "${ARCHIVE_FILE}" && \
        echo "NPM cache saved."
      else
        echo "Skipping NPM cache save (/workspace/${SOURCE_DIR} not found or empty)."
      fi

  # 6. Save .next Cache to GCS
  - id: save-next-cache
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk:slim' # Has tar and gsutil
    waitFor: ['npm-build'] # Save after build generates cache
    script: |
      #!/usr/bin/env bash
      set -Eeuo pipefail
      CACHE_PATH="gs://${_CACHE_BUCKET}/latest-${_CACHE_ARCHIVE_NEXT}"
      ARCHIVE_FILE="/workspace/${_CACHE_ARCHIVE_NEXT}" # Use workspace for temp file
      SOURCE_DIR=".next/cache" # Relative path in /workspace
      PARENT_DIR=".next"
      if [[ -d "/workspace/${SOURCE_DIR}" ]] && [[ -n "$(ls -A /workspace/${SOURCE_DIR})" ]]; then
        echo "Creating and uploading .next cache to ${CACHE_PATH}..."
        # Archive the 'cache' dir from within '.next'
        (cd "/workspace/${PARENT_DIR}" && tar --ignore-failed-read -czf "${ARCHIVE_FILE}" cache) && \
        gsutil -q -h "Cache-Control:private, max-age=0, no-transform" cp "${ARCHIVE_FILE}" "${CACHE_PATH}" && \
        rm "${ARCHIVE_FILE}" && \
        echo ".next cache saved."
      else
        echo "Skipping .next cache save (/workspace/${SOURCE_DIR} not found or empty)."
      fi

  # 7. Build and Push Docker Image (Using simplified Dockerfile v11)
  # Uses artifacts created in /workspace by steps 3 & 4
  - id: docker-build
    name: 'gcr.io/cloud-builders/docker'
    waitFor: ['npm-build'] # Wait for workspace build to finish
    args:
      - 'build'
      - '--tag'
      - '${_IMAGE_NAME}:${COMMIT_SHA}'
      - '--tag'
      - '${_IMAGE_NAME}:${_LATEST_TAG_NAME}' # Tag as 'latest' for cache-from
      # Use cache from previous 'latest' build for Docker layers if possible
      - '--cache-from'
      - '${_IMAGE_NAME}:${_LATEST_TAG_NAME}'
      - '.' # Context is /workspace

  - id: docker-push
    name: 'gcr.io/cloud-builders/docker'
    waitFor: ['docker-build', 'save-npm-cache', 'save-next-cache'] # Wait for build and cache saves
    args: ['push', '${_IMAGE_NAME}'] # Pushes all tags (COMMIT_SHA, latest)

  # 8. Deploy to Cloud Run (User's existing deploy step)
  - id: cloudrun-deploy
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk:slim'
    waitFor: ['docker-push']
    entrypoint: gcloud
    args:
      - 'run'
      - 'services'
      - 'update'
      - '${_SERVICE_NAME}'
      - '--platform=managed'
      - '--image=${_IMAGE_NAME}:${COMMIT_SHA}' # Deploy specific commit
      - '--labels=managed-by=gcp-cloud-build-deploy-cloud-run,commit-sha=${COMMIT_SHA},gcb-build-id=${BUILD_ID},gcb-trigger-id=${_TRIGGER_ID}'
      - '--region=${_DEPLOY_REGION}'
      - '--quiet'
      - '--set-env-vars=NEXT_PUBLIC_SUPABASE_URL=${_NEXT_PUBLIC_SUPABASE_URL},NEXT_PUBLIC_SUPABASE_ANON_KEY=${_NEXT_PUBLIC_SUPABASE_ANON_KEY},NEXT_PUBLIC_BASE_URL=${_NEXT_PUBLIC_BASE_URL},NEXT_PUBLIC_LOGODEV_KEY=${_NEXT_PUBLIC_LOGODEV_KEY},NEXT_PUBLIC_GEMINI_API_KEY=${_NEXT_PUBLIC_GEMINI_API_KEY},NEXT_PUBLIC_MAPBOX_TOKEN=${_NEXT_PUBLIC_MAPBOX_TOKEN},NEXT_PUBLIC_GA_TRACKING_ID=${_NEXT_PUBLIC_GA_TRACKING_ID},REVALIDATION_SECRET_TOKEN=${_REVALIDATION_SECRET_TOKEN}'

# This section causes GCB to automatically push tagged images if steps succeed.
# Redundant if using explicit 'docker push' step, but harmless.
images:
  - '${_IMAGE_NAME}:${COMMIT_SHA}'
  - '${_IMAGE_NAME}:${_LATEST_TAG_NAME}'

tags:
  - gcp-cloud-build-deploy-cloud-run
  - gcp-cloud-build-deploy-cloud-run-managed
  - web-app